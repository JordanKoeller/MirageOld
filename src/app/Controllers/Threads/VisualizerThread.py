# -*- coding: utf-8 -*-
import time

from PyQt5 import QtCore

from app.Models import ModelImpl

from ...Utility.NullSignal import NullSignal
from ...Views.Drawer import DataVisualizerDrawer
from ...Views.Drawer.CompositeDrawerFactory import LensedImageLightCurveComposite


# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.6
#
# WARNING! All changes made in this file will be lost!
class VisualizerThread(QtCore.QThread):
    """
    For Internal Use only. 

    Class extending a Qt QThread class. Provides methods for interfacing with the physics ModelImpl.engine.
    Enables all calculations to be ran on a separate thread so as to not freeze the GUI.


    PARAMETERS
    ----------

    ModelImpl.engine : ModelImpl.engine
        Instance that the VisualizerThread controls
    canvas : QLabel or Matplotlib plot
        Canvas owned by the thread. This is the canas that images generated by the ModelImpl.engine are drawn to.
        Default Value: None
    canvasType : CanvasType
        Enum specifying if the canvas is a QLabel-based canvas or a Matplotlib-based canvas.
        DefaultValue: CanvasType.NONE_TYPE

    ATTRIBUTES
    ----------

    canvas : The canvas passed in either upon initialization of with the setCanvas method.

    ModelImpl.engine : The ModelImpl.engine instance passed in upon initialization of the VisualizerThread instance.


    METHODS
    -------

    setCanvas

    """

    def __init__(self,signals=NullSignal):
        QtCore.QThread.__init__(self)
        self.progress_bar_update  = signals['progressBar']
        self.progress_label_update = signals['progressLabel']
        self.image_canvas_update = signals['imageCanvas']
        self.curve_canvas_update = signals['curveCanvas']
        self.progress_bar_max_update = signals['progressBarMax']
        self.sourcePos_label_update = signals['paramLabel']
        self.__calculating = False
        self.__frameRate = 30
        self.__drawer = LensedImageLightCurveComposite(self.image_canvas_update,self.curve_canvas_update)
        self.circularPath = False

    def run(self):
        self.progress_label_update.emit("Ray-Tracing. Please Wait.")
        self.__calculating = True
        interval = 1/self.__frameRate
        counter = 0
        self.progress_label_update.emit("Animating.")
        while self.__calculating:
            counter += 1
            timer = time.clock()
            pixels = ModelImpl.engine.getFrame()
            mag = ModelImpl.engine.getMagnification(pixels.shape[0])
            self.__drawer.draw([ModelImpl.parameters,pixels],[mag])
            self.sourcePos_label_update.emit(str(ModelImpl.parameters.quasar.position.to('arcsec')))
            ModelImpl.parameters.incrementTime(ModelImpl.parameters.dt)
            ModelImpl.moveStars()
            deltaT = time.clock() - timer
            if deltaT < interval:
                time.sleep(interval-deltaT)


    def pause(self):
        self.progress_label_update.emit("Paused.")
        self.__calculating = False

    def restart(self):
        self.progress_label_update.emit("Restarted.")
        self.__calculating = False
        ModelImpl.parameters.setTime(0)
        pixels = ModelImpl.engine.getFrame()
        mag = ModelImpl.engine.getMagnification(len(pixels))
        self.__drawer.draw([ModelImpl.parameters,pixels],[mag])
        self.sourcePos_label_update.emit(str(ModelImpl.parameters.quasar.position.to('arcsec')))
        self.__drawer.reset()

    def visualize(self,params):
        self.progress_label_update.emit("Ray-Tracing. Please Wait.")
        drawer = DataVisualizerDrawer(self.image_canvas_update)
        ModelImpl.updateParameters(params)
        self.progress_label_update.emit("Calculating Magnification Coefficients. Please Wait.")
        pixels = ModelImpl.engine.visualize()
        drawer.draw([pixels])
        self.progress_label_update.emit("Done.")
        return pixels

