'''
Created on Jun 7, 2017

@author: jkoeller
'''

import copy
import math


import numpy as np

from ..Parameters.ExperimentParams import LightCurveParameters, MagMapParameters, StarFieldData
from .AbstractFileWrapper import AbstractFileWrapper


class Trial(AbstractFileWrapper):
    '''
    Class providing convenient ways to interract with data generated by one trial of a gravitationally lensed system.

    Can be constructed directly, but recommended to construct by indexing a :class:`la.Experiment' instance.
    '''
    def __init__(self,filepath,trialno,fileobject=None,params=None,lookuptable=[]):
        AbstractFileWrapper.__init__(self, filepath, fileobject, params, lookuptable)    
        self.__trialNo = trialno

    def requiresDtype(dtype):
        def decorator(fn):
            def decorated(self,*args,**kwargs):
                for k,v in self._exptTypes.items():
                    if isinstance(k, dtype):
                        index = v
                        return fn(self,index,*args,**kwargs)
                raise AttributeError("Trial does not contain "+str(dtype) +" data.")
            return decorated
        return decorator
    
    
    
    @requiresDtype(LightCurveParameters)
    def getLightCurve(self,ind,xUnit = 'arcsec'): #Automatically passed in parameter 'ind' supplies information of what column that data type is located in
        '''
            Requires the trial have light curve data.

            Returns a tuple containing the X and Y axes of a light curve run. X axis represents distance traveled by quasar, Y axis represents magnfication coefficient.

            Parameters: 'xUnit' (:class:'str') Unit to measure the x axis in. 
        '''
        lc = self._getDataSet(ind)
        x = np.arange(0,len(lc))
        distCovered = self.parameters.extras.desiredResults[ind].pathEnd - self.parameters.extras.desiredResults[ind].pathStart
        dist = distCovered.to(xUnit).magnitude()/len(lc)
        x = x * dist
        return (x,lc)
    
    
    @requiresDtype(MagMapParameters)
    def getFitsFile(self,ind,filename = None,**kwargs):
        '''
        Constructs a FITS file for visualizing the trial's magnification map data. Requires the trial contain magnification map data.

        Parameters:

        `filename` (:class:`str`): File to save the FITS data to. If none is open, attempts to open a file dialog to prompt the user.
        Additional arguments passed in will be inserted into the FITS file's header. The keyword supplied becomes a new field in the 
        header, and the argument is converted to a string and given as that field's body.
        '''
        from ..Controllers.FileManagerImpl import FITSFileWriter
        arr = self._getDataSet(ind)
        fm = FITSFileWriter()
        fm.open(filename)
        fm.write(arr,**kwargs)
        fm.close()
        print("Magnification Map saved")

    @requiresDtype(StarFieldData)
    def getStars(self,ind):
            return self._getDataSet(ind)

    @requiresDtype(StarFieldData)
    @requiresDtype(MagMapParameters)
    def superimpose_stars(self,magIndex,starsIndex,magmapimg=None,destination=None,color = (255,255,0,255)):
        '''DEPRECATED'''
        parameters = self.regenerateParameters()
        from PIL import Image
        img = Image.open(magmapimg)
        pix = img.load()
        stars = parameters.galaxy.stars
        dTheta = parameters.extras.desiredResults[magIndex].dimensions.to('rad')/parameters.extras.desiredResults[magIndex].resolution
        starCoords = stars[:,0:2]
        starMass = stars[:,2]
        starCoords[:,0] = starCoords[:,0]/dTheta.x + parameters.extras.desiredResults[magIndex].resolution.x/2
        starCoords[:,1] = starCoords[:,1]/dTheta.y + parameters.extras.desiredResults[magIndex].resolution.y/2
        # starCoords[:,0] = starCoords[:,0]*dTheta.x/parameters.dTheta.to('rad').value
        # starCoords[:,1] = starCoords[:,1]*dTheta.y/parameters.dTheta.to('rad').value
        starCoords = np.ascontiguousarray(starCoords,dtype=np.int32)
        for row in range(0,starCoords.shape[0]):
            x,y = (starCoords[row,0],starCoords[row,1])
            mass = starMass[row]
            r = int(math.sqrt(mass+2))
            for i in range(x-r,x+r):
                for j in range(y-r,y+r):
                    if i >= 0 and i < parameters.extras.desiredResults[magIndex].resolution.x and j >= 0 and j < parameters.extras.desiredResults[magIndex].resolution.y:
                        pix[j,i] = color
        img.save(destination)
        print("Superimposed image saved as "+destination)

        
    @requiresDtype(StarFieldData)
    def regenerateParameters(self,ind):
        '''
        Constructs and returns a :class:`app.Parameters` instance, exactly as it was when the :class:`Trial` was calculated.
        '''
        from ..Controllers.FileManagerImpl import ParametersFileManager
        params = copy.deepcopy(self.parameters)
        stars = self.getStars()
        params.setStars(stars)
        return params
        
    @requiresDtype(StarFieldData)
    @requiresDtype(MagMapParameters)
    def traceQuasar(self,magIndex,starsIndex):
        '''
        DEPRECATED
        '''
        magnifications = self._getDataSet(magIndex)
        params = self.regenerateParameters()
        return (magnifications,params)
        
    def saveParameters(self,filename=None):
        '''DEPRECATED'''
        from ..Controllers.FileManagerImpl import ParametersFileManager
        saver = ParametersFileManager()
        if filename:
            saver.write(copy.deepcopy(self.parameters),filename)
        else:
            saver.write(copy.deepcopy(self.parameters))
        print("parameters Saved")
        
    @property
    def trialNumber(self):
        '''
        Returns this trial's index within the experiment calculated.
        '''
        return self.__trialNo

    @property
    def parameters(self):
        '''
        See :class:`regenerateParameters`
        '''
        return self.regenerateParameters()

    
    
    @property
    def datasets(self):
        '''
            Returns a generator, iterating through the different data sets enclosed in the trial.
        '''
        index = 0
        while index < self._lookupTable.shape[1]:
            yield self._getDataSet(self.__trialNo, index)
            
            
    def _getDataSet(self,tableNo):
            self._fileobject.seek(self._lookupTable[self.__trialNo,tableNo])
            return np.load(self._fileobject)