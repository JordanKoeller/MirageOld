import numpy as np
import copy
import glob
import os
import sys

from .AbstractFileWrapper import AbstractFileWrapper

from ..parameters.ExperimentParams import LightCurveParameters, \
    MagMapParameters, StarFieldData, BatchLightCurveParameters, \
    RDDFileInfo
from ..calculator.ExperimentResultCalculator import varyTrial

def _requiresDtype(dtype):
    def decorator(fn):
        def decorated(self,*args,**kwargs):
            for k,v in self._exptTypes.items():
                if isinstance(k, dtype):
                    index = v
                    return fn(self,index,*args,**kwargs)
            raise AttributeError("Trial does not contain "+str(dtype) +" data.")
        setattr(decorated,'__doc__',getattr(fn, '__doc__'))
        return decorated
    return decorator

class Trial(AbstractFileWrapper):
    '''
    Class providing convenient ways to interract with data generated by one trial of a gravitationally lensed system.
    This is the workhorse class of the :class:`lens_analysis` module. Provides the methods for accessing data, getting statistical info, 
    etc.

    Can be constructed directly, but recommended to construct by indexing a :class:`la.Experiment` instance.
    '''
    def __init__(self,filepath,trialno,fileobject=None,params=None,lookuptable=[]):
        AbstractFileWrapper.__init__(self, filepath, fileobject, params, lookuptable)    
        self.__trialNo = trialno

    
    @property
    @_requiresDtype(LightCurveParameters)
    def lightCurve(self,ind,xUnit = 'arcsec'): #Automatically passed in parameter 'ind' supplies information of what column that data type is located in
        '''
        Requires the trial have light curve data.

        Returns a tuple containing the X and Y axes of a light curve run. X axis represents distance traveled by quasar, Y axis represents magnfication coefficient.

        Parameters: `xUnit` (:class:`str`) Unit to measure the x axis in. 
        '''
        lc = self._getDataSet(ind)
        x = np.arange(0,len(lc))
        distCovered = self.parameters.extras.desiredResults[ind].pathEnd - self.parameters.extras.desiredResults[ind].pathStart
        dist = distCovered.to(xUnit).magnitude()/len(lc)
        x = x * dist
        return (x,lc)
    
    
    @_requiresDtype(MagMapParameters)
    def getFitsFile(self,ind,filename = None,**kwargs):
        '''
        Constructs a FITS file for visualizing the trial's magnification map data. Requires the trial contain magnification map data.

        Parameters:

        `filename` (:class:`str`): File to save the FITS data to. If none is open, attempts to open a file dialog to prompt the user.
        Additional arguments passed in will be inserted into the FITS file's header. The keyword supplied becomes a new field in the 
        header, and the argument is converted to a string and given as that field's body.
        '''
        from app.io import FITSFileWriter
        arr = self._getDataSet(ind)
        fm = FITSFileWriter()
        fm.open(filename)
        fm.write(arr,**kwargs)
        fm.close()
        print("Magnification Map saved")

    @_requiresDtype(StarFieldData)
    def getStars(self,ind):
            return self._getDataSet(ind)


    @_requiresDtype(StarFieldData)
    def regenerateParameters(self,ind):
        '''
        Constructs and returns a :class:`app.Parameters` instance, exactly as it was when the :class:`Trial` was calculated.
        '''
        params = copy.deepcopy(self.parameters)
        stars = self.getStars()
        params.setStars(stars)
        return params    

    @property
    def parameters(self):
        params = copy.deepcopy(self._params)
        params =  varyTrial(params,self.trialNumber)
        try:
            stars = self.getStars()
            params.setStars(stars)
        except:
            pass
        try:
            fname = self.rddFileInfo
            params.getExtras('datafile').set_filename(fname)
        finally:
            return params



    def histogram(self,numBuckets=100):
        '''
        Constructs a histogram from the :class:`Trial`'s data. Requires the instance contain Magnification map data.
        
        Parameters:
            `numBuckets` (:class:`int`): Number of buckets to divide the data into. Defaults to 100.
            
        Returns:
            Tuple of the counts calculated and buckets used (`counts,buckets`). 
        '''
        mm = self.magMap
        ret = np.histogram(mm,numBuckets+1)
        return (ret[0],ret[1][1:])
        
    @_requiresDtype(StarFieldData)
    @_requiresDtype(MagMapParameters)
    def traceQuasar(self,magIndex,starsIndex):
        '''
        DEPRECATED
        '''
        magnifications = self._getDataSet(magIndex)
        params = self.regenerateParameters()
        return (magnifications,params)
        
        
    @property
    def trialNumber(self):
        '''
        Returns this trial's index within the experiment calculated.
        '''
        return self.__trialNo

    @property
    @_requiresDtype(RDDFileInfo)
    def rddFileInfo(self,index):
        filename = self._getDataSet(index)[0]
        return filename

    
    @property
    def datasets(self):
        '''
        Returns a generator, iterating through the different data sets enclosed in the trial.
        '''
        index = 0
        while index < self._lookupTable.shape[1]:
            yield self._getDataSet(self.__trialNo, index)
            
    @property
    @_requiresDtype(MagMapParameters)
    def magMap(self,ind):
        '''
        Requires Magnification Map data. Returns the magnification map data as a numpy array.
        '''
        return self._getDataSet(ind)
            
            
    def _getDataSet(self,tableNo):
        '''
        Internal Method. Allows access to any dataset at the given index in the lookup table.
        '''
        self._fileobject.seek(self._lookupTable[self.__trialNo,tableNo])
        return np.load(self._fileobject)
  

    @property
    @_requiresDtype(BatchLightCurveParameters)
    def lightcurves(self,ind):
        from app.models import LightCurveBatch
        curves_array = self._getDataSet(ind)
        return LightCurveBatch(curves_array)


