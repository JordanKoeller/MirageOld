# -*- coding: utf-8 -*-
import time

from PyQt5 import QtCore

from Views.Drawer import DataVisualizerDrawer
from Views.Drawer.CompositeDrawerFactory import LensedImageLightCurveComposite
import numpy as np


# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.6
#
# WARNING! All changes made in this file will be lost!
class SimThread(QtCore.QThread):
    """
    For Internal Use only. 

    Class extending a Qt QThread class. Provides methods for interfacing with the physics engine.
    Enables all calculations to be ran on a separate thread so as to not freeze the GUI.


    PARAMETERS
    ----------

    engine : Engine
        Instance that the SimThread controls
    canvas : QLabel or Matplotlib plot
        Canvas owned by the thread. This is the canas that images generated by the engine are drawn to.
        Default Value: None
    canvasType : CanvasType
        Enum specifying if the canvas is a QLabel-based canvas or a Matplotlib-based canvas.
        DefaultValue: CanvasType.NONE_TYPE

    ATTRIBUTES
    ----------

    canvas : The canvas passed in either upon initialization of with the setCanvas method.

    engine : The engine instance passed in upon initialization of the SimThread instance.


    METHODS
    -------

    setCanvas

    """

    def __init__(self,engine,signals):
        QtCore.QThread.__init__(self)
        self.progress_bar_update  = signals[0]
        self.progress_label_update = signals[1]
        self.image_canvas_update = signals[2]
        self.curve_canvas_update = signals[3]
        self.progress_bar_max_update = signals[4]
        self.sourcePos_label_update = signals[5]
        self.__calculating = False
        self.__frameRate = 60
        self.engine = engine
        self.__drawer = LensedImageLightCurveComposite(self.image_canvas_update,self.curve_canvas_update)
        self.parameters = None
        self.circularPath = False

    def updateParameters(self,params):
        if self.parameters:
            params.setTime(self .parameters.time)
            params.quasar.setPos(self.parameters.quasar.observedPosition)
        self.parameters = params

    def run(self):
        self.progress_label_update.emit("Ray-Tracing. Please Wait.")
        self.engine.updateParameters(self.parameters)
        self.__calculating = True
        interval = 1/self.__frameRate
        counter = 0
        self.progress_label_update.emit("Animating.")
        while self.__calculating:
            counter += 1
            timer = time.clock()
            pixels = self.engine.getFrame()
            mag = self.engine.getMagnification(len(pixels))
            img = self.__drawer.draw([self.parameters,pixels],[mag])
            self.sourcePos_label_update.emit(str(self.parameters.quasar.position.orthogonal.setUnit('rad').to('arcsec')))
            # if self.circularPath:
            self.parameters.quasar.circularPath()
            self.parameters.incrementTime(self.parameters.dt)
            deltaT = time.clock() - timer
            if deltaT < interval:
                time.sleep(interval-deltaT)


    def pause(self):
        self.progress_label_update.emit("Paused.")
        self.__calculating = False

    def restart(self):
        self.progress_label_update.emit("Restarted.")
        self.__calculating = False
        self.parameters.setTime(0)
        pixels = self.engine.getFrame()
        mag = self.engine.getMagnification(len(pixels))
        frame = self.__drawer.draw([self.parameters,pixels],[mag])
        self.sourcePos_label_update.emit(str(self.parameters.quasar.position.orthogonal.setUnit('rad').to('arcsec')))
        self.__drawer.reset()

    def visualize(self,params):
        self.progress_label_update.emit("Ray-Tracing. Please Wait.")
        drawer = DataVisualizerDrawer(self.image_canvas_update)
        self.engine.updateParameters(params)
        self.progress_label_update.emit("Calculating Magnification Coefficients. Please Wait.")
        pixels = self.engine.visualize()
        frame = drawer.draw([pixels])
        self.progress_label_update.emit("Done.")
        return pixels

    def bin_test(self):
        binszs = np.arange(7000,65000,100)
        reps = 200
        prevRunner = self.run
        self.progress_label_update.emit("Calculating Various Bin Sizes.")
        self.progress_bar_max_update.emit(len(binszs))
        def runner():
            self.engine.gridTest(binszs, reps,self.curve_canvas_update,self.progress_bar_update)
            # self.__calculating = False
        self.run = runner
        self.start()
        # print("Asynchronous")
