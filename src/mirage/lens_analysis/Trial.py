import numpy as np
import copy
import glob
import os
import sys

from .AbstractFileWrapper import AbstractFileWrapper

from ..parameters.ExperimentParams import MagMapParameters, BatchLightCurveParameters
from ..calculator.ExperimentResultCalculator import varyTrial

def _requiresDtype(dtype):
    def decorator(fn):
        def decorated(self,*args,**kwargs):
            for k,v in self.experiments.items():
                if isinstance(k, dtype):
                    index = v
                    return fn(self,index,*args,**kwargs)
            raise AttributeError("Trial does not contain "+str(dtype) +" data.")
        setattr(decorated,'__doc__',getattr(fn, '__doc__'))
        return decorated
    return decorator

class Trial(AbstractFileWrapper):
    '''
    Class providing convenient ways to interract with data generated by one trial of a gravitationally lensed system.
    This is the workhorse class of the :class:`lens_analysis` module. Provides the methods for accessing data, getting statistical info, 
    etc.

    Can be constructed directly, but recommended to construct by indexing a :class:`la.Experiment` instance.
    '''
    def __init__(self,filepath,trialno,fileobject=None,simulation=None,lookuptable=[]):
        AbstractFileWrapper.__init__(self, filepath, fileobject, simulation, lookuptable)    
        self.__trialNo = trialno
    
    
    @_requiresDtype(MagMapParameters)
    def getFitsFile(self,ind,filename = None,**kwargs):
        '''
        Constructs a FITS file for visualizing the trial's magnification map data. Requires the trial contain magnification map data.

        Parameters:

        `filename` (:class:`str`): File to save the FITS data to. If none is open, attempts to open a file dialog to prompt the user.
        Additional arguments passed in will be inserted into the FITS file's header. The keyword supplied becomes a new field in the 
        header, and the argument is converted to a string and given as that field's body.
        '''
        from mirage.io import FITSFileWriter
        arr = self._getDataSet(ind)
        fm = FITSFileWriter()
        fm.open(filename)
        fm.write(arr,**kwargs)
        fm.close()
        print("Magnification Map saved")

    def getStars(self):
            return self.parameters.stars 

    @property
    def parameters(self):
        sim = copy.deepcopy(self.simulation)
        params =  varyTrial(sim,self.trialNumber).parameters
        return params



    def histogram(self,numBuckets=100):
        '''
        Constructs a histogram from the :class:`Trial`'s data. Requires the instance contain Magnification map data.
        
        Parameters:
            `numBuckets` (:class:`int`): Number of buckets to divide the data into. Defaults to 100.
            
        Returns:
            Tuple of the counts calculated and buckets used (`counts,buckets`). 
        '''
        mm = self.magMap
        ret = np.histogram(mm,numBuckets+1)
        return (ret[0],ret[1][1:])
        
    @_requiresDtype(MagMapParameters)
    def traceQuasar(self,magIndex,starsIndex):
        '''
        DEPRECATED
        '''
        magnifications = self._getDataSet(magIndex)
        params = self.regenerateParameters()
        return (magnifications,params)
        
        
    @property
    def trialNumber(self):
        '''
        Returns this trial's index within the experiment calculated.
        '''
        return self.__trialNo

    
    @property
    def datasets(self):
        '''
        Returns a generator, iterating through the different data sets enclosed in the trial.
        '''
        index = 0
        while index < self._lookupTable.shape[1]:
            yield self._getDataSet(self.__trialNo, index)
            
    @property
    @_requiresDtype(MagMapParameters)
    def magMap(self,ind):
        '''
        Requires Magnification Map data. Returns the magnification map data as a numpy array.
        '''
        return self._getDataSet(ind)
            
            
    def _getDataSet(self,tableNo):
        '''
        Internal Method. Allows access to any dataset at the given index in the lookup table.
        '''
        self._fileobject.seek(self._lookupTable[self.__trialNo,tableNo])
        return np.load(self._fileobject)
  

    @property
    @_requiresDtype(BatchLightCurveParameters)
    def lightcurves(self,ind):
        from mirage.light_curves import LightCurveBatch, LightCurve
        curves_array = self._getDataSet(ind)
        curves = []
        for i in range(curves_array.shape[0]):
            c,q = curves_array[i]
            lc = LightCurve(c,q)
            curves.append(lc)
        return LightCurveBatch(curves)


