# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.6
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets, uic
from Engine_cl import Engine_cl
from Configs import Configs
from stellar import Galaxy
from stellar import Quasar
from stellar import defaultGalaxy
from stellar import defaultQuasar
from Configs import defaultConfigs
from stellar import microGalaxy
from stellar import microQuasar
from Configs import microConfigs
import threading as par
from Vector2D import Vector2D, zeroVector
from enum import Enum
import time
from astropy import units as u

class CanvasType(Enum):
    LABEL_CANVAS = 0
    MPL_CANVAS = 1
    NONE_TYPE = 2

class SimThread(QtCore.QThread):
    """
    For Internal Use only. 

    Class extending a Qt QThread class. Provides methods for interfacing with the physics engine.
    Enables all calculations to be ran on a separate thread so as to not freeze the GUI.


    PARAMETERS
    ----------

    engine : Engine
        Instance that the SimThread controls
    canvas : QLabel or Matplotlib plot
        Canvas owned by the thread. This is the canas that images generated by the engine are drawn to.
        Default Value: None
    canvasType : CanvasType
        Enum specifying if the canvas is a QLabel-based canvas or a Matplotlib-based canvas.
        DefaultValue: CanvasType.NONE_TYPE

    ATTRIBUTES
    ----------

    canvas : The canvas passed in either upon initialization of with the setCanvas method.

    engine : The engine instance passed in upon initialization of the SimThread instance.


    METHODS
    -------

    setCanvas

    """
    def __init__(self,engine,canvas = None):
        QtCore.QThread.__init__(self)
        self.engine = engine
        self.canvas = canvas
        self.__calculating = False
        self.__reconfiguring = False
        self.__drawingGalaxy = True
        self.__drawingQuasar = True


    def setCanvas(self,canvas, canvasType = CanvasType.LABEL_CANVAS):
        self.canvas = canvas
        filler_img = QtGui.QImage(1200,1200, QtGui.QImage.Format_Indexed8)
        filler_img.setColorTable([QtGui.qRgb(0,0,0)])
        filler_img.fill(0)
        self.canvas.setPixmap(QtGui.QPixmap.fromImage(filler_img))

    def run(self):
        self.canvas.setPixmap(QtGui.QPixmap.fromImage(self.engine.img))
        self.__calculating = True
        interval = 1/self.engine.configs.frameRate
        while self.__calculating:
            timer = time.clock()
            frame = self.engine.getFrame()
            self.engine.time += self.engine.configs.dt
            self.canvas.pixmap().convertFromImage(frame)
            self.canvas.update()
            deltaT = time.clock() - timer
            if deltaT < interval:
                time.sleep(interval-deltaT)

    def pause(self):
        self.__calculating = False

    def restart(self):
        self.pause()
        self.engine.time = 0.0
        frame = self.engine.getFrame()
        self.canvas.pixmap().convertFromImage(frame)
        self.canvas.update()

    def updateDrawingGalaxy(self, drawGalaxy, isMicrolensing):
        if drawGalaxy and isMicrolensing:
            self.engine.updateConfigs(displayGalaxy = False, displayStars = True)
        elif not isMicrolensing:
            self.engine.updateConfigs(displayGalaxy = True, displayStars = True)
        else:
            self.engine.updateConfigs(displayGalaxy = False, displayStars = False)



class Ui_MainWindow(QtWidgets.QMainWindow):
    def __init__(self, parent = None):
        super(Ui_MainWindow, self).__init__(parent)
        uic.loadUi('GUI/gui.ui', self)
        self.simThread = SimThread(Engine_cl(defaultQuasar,defaultGalaxy,defaultConfigs, auto_configure = False))
        self.setupUi()


    # @property
    # def engine(self):
    #     return self.simThread.engine


    def setupUi(self):
        """
        Adds functionality to the user interface. In other words, makes it so buttons, images, checkboxes, textfields, etc. do things.
        Override or add to method to alter user interraction outcomes.
        Called upon initialization.
        """
        self.simThread.setCanvas(self.main_canvas)
        self.pauseButton.clicked.connect(self.simThread.pause)
        self.resetButton.clicked.connect(self.simThread.restart)
        self.playButton.clicked.connect(self.startSim)
        self.displayQuasar.clicked.connect(self.drawQuasarHelper)
        self.displayGalaxy.clicked.connect(self.drawGalaxyHelper)


    def __vector_from_qstring(self,string,reverse_y = True):
        """
        Converts an ordered pair string of the form (x,y) into a Vector2D of x and y.
        Flips the sign of the y coordinate to translate computer coordinate systems of
        y increasing down to the conventional coordinate system of y increasing up.
        """
        x,y = (string.strip('()')).split(',')
        if (reverse_y):
            ret = Vector2D(float(x),-float(y))
            return ret
        else:
            ret = Vector2D(float(x),float(y))
            return ret

    def makeConfigs(self):
        displayQuasar = self.displayQuasar.isChecked()
        displayGalaxy = self.displayGalaxy.isChecked()
        displayStars = self.displayGalaxy.isChecked()
        isMicrolensing = self.enableMicrolensingBox.isChecked()
        dimensionInput = int(self.dimensionInput.text())
        if isMicrolensing:
            displayGalaxy = False
            displayQuasar = False
        if self.autoConfigCheckBox.isChecked():
            er = self.simThread.engine.einsteinRadius
            er *= 1.5
            dTheta = er/(dimensionInput/2) #400 because dTheta has to be *2, since specifying a diameter from a radius.
            # self.simThread.engine.updateGalaxy(center = Vector2D(self.simThread.engine.einsteinRadius,0))
            configs = Configs(0.1,dTheta,dimensionInput,25,displayGalaxy,displayQuasar,displayStars)
            return configs
        else:
            scaleInput = u.Quantity(float(self.scaleInput.text()),'arcsec').to('rad').value
            configs = Configs(0.1,scaleInput/dimensionInput, dimensionInput, 25, displayGalaxy, displayQuasar, displayStars)
            return configs


    def pull_from_input(self):
        """
        Collects and parses all the information from the various user input fields/checkboxes.
        Stores them in instances of a Quasar class, Galaxy class, and Configs class.
        Returns the instances in that order as a tuple.
        """
        qVelocity = self.__vector_from_qstring(self.qVelocity.text()).setUnit('arcsec')
        qPosition = self.__vector_from_qstring(self.qPosition.text()).setUnit('arcsec')
        qRadius = u.Quantity(float(self.qRadius.text()),'arcsec')
        qRedshift = float(self.qRedshift.text())
        gRedshift = float(self.gRedshift.text())
        gVelDispersion = u.Quantity(float(self.gVelDispersion.text()),'km/s')
        gNumStars = int(self.gNumStars.text())
        gShearMag = float(self.gShearMag.text())
        gShearAngle = u.Quantity(float(self.gShearAngle.text()),'degree')
        galaxyCenter = zeroVector
        if self.enableMicrolensingBox.isChecked():
            galaxyCenter = Vector2D(self.simThread.engine.einsteinRadius,0)
        quasar = Quasar(redshift = qRedshift,position = qPosition,radius = qRadius,velocity = qVelocity)
        galaxy = Galaxy(redshift = gRedshift,velocityDispersion = gVelDispersion,shearMag = gShearMag,shearAngle = gShearAngle, percentStars = gNumStars/100, center = galaxyCenter)
        return (quasar,galaxy)

    def startSim(self):
        """
        Reads user input, updates the engine, and instructs the engine to begin
        __calculating what the user desired.

        Called by default when the "Play" button is presssed.
        """
        configs = self.makeConfigs()
        quasar,galaxy = self.pull_from_input()
        self.simThread.engine.updateConfigs(dt = configs.dt,dTheta = configs.dTheta,canvasDim = configs.canvasDim,frameRate = configs.frameRate,displayGalaxy = configs.displayGalaxy,displayQuasar = configs.displayQuasar, isMicrolensing = self.enableMicrolensingBox.isChecked(), auto_configure = False)
        self.simThread.engine.updateGalaxy(redshift = galaxy.redshift,velocityDispersion = galaxy.velocityDispersion,shearMag = galaxy.shearMag,shearAngle = galaxy.shearAngle,center = galaxy.position,percentStars = galaxy.percentStars,auto_configure = False)
        self.simThread.engine.updateQuasar(redshift = quasar.redshift,radius = quasar.radius,position = quasar.position,velocity = quasar.velocity,auto_configure = False)
        self.simThread.start()

    def drawGalaxyHelper(self):
        self.simThread.updateDrawingGalaxy(self.displayGalaxy.isChecked(),self.enableMicrolensingBox.isChecked())
    def drawQuasarHelper(self):
        self.simThread.engine.updateConfigs(displayQuasar = self.displayQuasar.isChecked())

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    ui = Ui_MainWindow()
    ui.show()
    sys.exit(app.exec_())

