# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.6
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets, uic
from Engine_cl import Engine_cl as Engine
from Configs import Configs
from stellar import Galaxy
from stellar import Quasar
from stellar import defaultGalaxy
from stellar import defaultQuasar
from Configs import defaultConfigs
from stellar import microGalaxy
from stellar import microQuasar
from Configs import microConfigs
import threading as par
from Vector2D import Vector2D, zeroVector
from enum import Enum
import time
from astropy import units as u
from Parameters import Parameters
from DynamicCanvas import DynamicCanvas
from matplotlib import pyplot as pl

class CanvasType(Enum):
    LABEL_CANVAS = 0
    MPL_CANVAS = 1
    NONE_TYPE = 2

class SimThread(QtCore.QThread):
    """
    For Internal Use only. 

    Class extending a Qt QThread class. Provides methods for interfacing with the physics engine.
    Enables all calculations to be ran on a separate thread so as to not freeze the GUI.


    PARAMETERS
    ----------

    engine : Engine
        Instance that the SimThread controls
    canvas : QLabel or Matplotlib plot
        Canvas owned by the thread. This is the canas that images generated by the engine are drawn to.
        Default Value: None
    canvasType : CanvasType
        Enum specifying if the canvas is a QLabel-based canvas or a Matplotlib-based canvas.
        DefaultValue: CanvasType.NONE_TYPE

    ATTRIBUTES
    ----------

    canvas : The canvas passed in either upon initialization of with the setCanvas method.

    engine : The engine instance passed in upon initialization of the SimThread instance.


    METHODS
    -------

    setCanvas

    """
    def __init__(self,canvas = None):
        QtCore.QThread.__init__(self)
        self.canvas = canvas
        self.__calculating = False
        self.__frameRate = 25
        self.engine = Engine()
        self.operation = ""
        self.progressBar = None

    def setCanvas(self,canvas, canvasType = CanvasType.LABEL_CANVAS):
        self.canvas = canvas
        filler_img = QtGui.QImage(1200,1200, QtGui.QImage.Format_Indexed8)
        filler_img.setColorTable([QtGui.qRgb(0,0,0)])
        filler_img.fill(0)
        self.canvas.setPixmap(QtGui.QPixmap.fromImage(filler_img))

    def updateParameters(self,params):
        self.engine.updateParameters(params)

    def run(self):
        self.__calculating = True
        if self.operation == "Image":
            interval = 1/self.__frameRate
            while self.__calculating:
                timer = time.clock()
                frame,dt = self.engine.getFrame()
                self.engine.time += dt
                self.canvas.pixmap().convertFromImage(frame)
                self.canvas.update()
                deltaT = time.clock() - timer
                if deltaT < interval:
                    time.sleep(interval-deltaT)
        elif self.operation == "Light Curve":
            x,y = self.engine.makeLightCurve(Vector2D(-0.05,-0.05),Vector2D(0.05,0.05),progressBar = self.progressBar,canvas = self.canvas)
            print("returned the stuff")
            pl.plot(x,y)
            pl.show()

    def pause(self):
        self.__calculating = False

    def restart(self):
        self.pause()
        self.engine.time = 0.0
        frame = self.engine.getFrame()[0]
        self.canvas.pixmap().convertFromImage(frame)
        self.canvas.update()



class Ui_MainWindow(QtWidgets.QMainWindow):
    def __init__(self, parent = None):
        super(Ui_MainWindow, self).__init__(parent)
        uic.loadUi('GUI/gui.ui', self)
        self.simThread = SimThread()
        self.setupUi()


    def setupUi(self):
        """
        Adds functionality to the user interface. In other words, makes it so buttons, images, checkboxes, textfields, etc. do things.
        Override or add to method to alter user interraction outcomes.
        Called upon initialization.
        """
        self.simThread.setCanvas(self.main_canvas)
        self.pauseButton.clicked.connect(self.simThread.pause)
        self.resetButton.clicked.connect(self.simThread.restart)
        self.playButton.clicked.connect(self.startSim)
        self.displayQuasar.clicked.connect(self.drawQuasarHelper)
        self.displayGalaxy.clicked.connect(self.drawGalaxyHelper)
        self.simThread.operation = self.modeComboBox.currentText()
        self.simThread.progressBar = self.progressBar


    def __vector_from_qstring(self,string,reverse_y = True):
        """
        Converts an ordered pair string of the form (x,y) into a Vector2D of x and y.
        Flips the sign of the y coordinate to translate computer coordinate systems of
        y increasing down to the conventional coordinate system of y increasing up.
        """
        x,y = (string.strip('()')).split(',')
        if (reverse_y):
            ret = Vector2D(float(x),-float(y))
            return ret
        else:
            ret = Vector2D(float(x),float(y))
            return ret

    def makeParameters(self):
        """
        Collects and parses all the information from the various user input fields/checkboxes.
        Stores them in instances of a Quasar class, Galaxy class, and Configs class.
        Returns the instances in that order as a tuple.
        """
        qVelocity = self.__vector_from_qstring(self.qVelocity.text()).setUnit('arcsec').to('rad')
        qPosition = self.__vector_from_qstring(self.qPosition.text()).setUnit('arcsec').to('rad')
        qRadius = u.Quantity(float(self.qRadius.text()),'arcsec')
        qRedshift = float(self.qRedshift.text())

        gRedshift = float(self.gRedshift.text())
        gVelDispersion = u.Quantity(float(self.gVelDispersion.text()),'km/s')
        gPercentStars = int(self.gNumStars.text())
        gShearMag = float(self.gShearMag.text())
        gShearAngle = u.Quantity(float(self.gShearAngle.text()),'degree')

        dTheta = u.Quantity(float(self.scaleInput.text()),'arcsec').to('rad').value
        canvasDim = int(self.dimensionInput.text())
        displayQuasar = self.displayQuasar.isChecked()
        displayGalaxy = self.displayGalaxy.isChecked()
        isMicrolensing = self.enableMicrolensingBox.isChecked()
        autoConfiguring = self.autoConfigCheckBox.isChecked()

        quasar = Quasar(qRedshift, qRadius, qPosition, qVelocity)
        galaxy = Galaxy(gRedshift, gVelDispersion, gShearMag, gShearAngle, gPercentStars)
        params = Parameters(isMicrolensing, autoConfiguring, galaxy, quasar, dTheta, canvasDim, displayGalaxy, displayQuasar)
        return params


    def drawQuasarHelper(self):
        self.simThread.engine.parameters.showQuasar = self.displayQuasar.isChecked()

    def drawGalaxyHelper(self):
        self.simThread.engine.parameters.showGalaxy = self.displayGalaxy.isChecked()

    def startSim(self):
        """
        Reads user input, updates the engine, and instructs the engine to begin
        __calculating what the user desired.

        Called by default when the "Play" button is presssed.
        """
        parameters = self.makeParameters()
        self.simThread.updateParameters(parameters)
        self.simThread.operation = self.modeComboBox.currentText()
        # self.main_canvas = DynamicCanvas()
        # self.simThread.setCanvas(self.main_canvas)
        self.simThread.start()



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    ui = Ui_MainWindow()
    ui.show()
    sys.exit(app.exec_())

