# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.6
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import uic
import pyqtgraph as pg
from pyqtgraph import QtCore, QtGui
import threading as par
import time
import imageio
import numpy as np
from Drawer import ImageDrawer
from Drawer import CurveDrawer


class SimThread(QtCore.QThread):
    """
    For Internal Use only. 

    Class extending a Qt QThread class. Provides methods for interfacing with the physics engine.
    Enables all calculations to be ran on a separate thread so as to not freeze the GUI.


    PARAMETERS
    ----------

    engine : Engine
        Instance that the SimThread controls
    canvas : QLabel or Matplotlib plot
        Canvas owned by the thread. This is the canas that images generated by the engine are drawn to.
        Default Value: None
    canvasType : CanvasType
        Enum specifying if the canvas is a QLabel-based canvas or a Matplotlib-based canvas.
        DefaultValue: CanvasType.NONE_TYPE

    ATTRIBUTES
    ----------

    canvas : The canvas passed in either upon initialization of with the setCanvas method.

    engine : The engine instance passed in upon initialization of the SimThread instance.


    METHODS
    -------

    setCanvas

    """

    progress_bar_update = QtCore.pyqtSignal(int)
    progress_label_update = QtCore.pyqtSignal(str)
    image_canvas_update = QtCore.pyqtSignal(object)
    curve_canvas_update = QtCore.pyqtSignal(object)

    def __init__(self,canvas,curveCanvas,progressLabel,progressBar,engine):
        QtCore.QThread.__init__(self)
        self.setCanvas(canvas)
        self.__calculating = False
        self.__frameRate = 40
        self.engine = engine
        self.progressBar = progressBar
        self.progressLabel = progressLabel
        self.__writer = None
        self.__movieRaw = []
        self.__drawer = ImageDrawer()
        # self.__curveDrawer = CurveDrawer(curveCanvas)

    def __asNPArray(self,im):
        im = im.convertToFormat(4)
        width = im.width()
        height = im.height()
        ptr = im.bits()
        ptr.setsize(im.byteCount())
        arr = np.array(ptr).reshape(height, width, 4)  #  Copies the data
        return arr

    def setCanvas(self,canvas):
        self.canvas = canvas
        filler_img = QtGui.QImage(800,800, QtGui.QImage.Format_Indexed8)
        filler_img.setColorTable([QtGui.qRgb(0,0,0)])
        filler_img.fill(0)
        self.canvas.setPixmap(QtGui.QPixmap.fromImage(filler_img))
        self.canvas.hide()

    def updateParameters(self,params):
        self.engine.updateParameters(params)

    def toggleRecording(self,writer):
        if self.__writer == None:
            self.__writer = imageio.get_writer(writer,fps=60)
            self.__movieRaw = []
        elif self.__movieRaw != []:
            counter = 0
            self.progressBar.setMinimum(0)
            self.progressBar.setMaximum(len(self.__movieRaw))
            self.progressLabel.setText("Rendering. Please Wait")
            for i in self.__movieRaw:
                arr = self.__asNPArray(i)
                self.__writer.append_data(arr)
                counter += 1
                self.progressBar.setValue(counter)
            self.__writer.close()
            self.__writer = None
            self.progressLabel.setText("File Saved.")
            self.progressBar.setValue(0)

    def __showFrame(self,frame):
        img = QtGui.QImage(frame.tobytes(),frame.shape[0],frame.shape[1],QtGui.QImage.Format_Indexed8)
        img.setColorTable([QtGui.qRgb(0,0,0),QtGui.qRgb(255,255,0),QtGui.qRgb(255,255,255),QtGui.qRgb(50,101,255),QtGui.qRgb(244,191,66)])
        self.image_canvas_update.emit(img)
        # self.canvas.pixmap().convertFromImage(img)
        # self.canvas.update()

    def run(self):
        self.progressLabel.setText("Running")
        self.__calculating = True
        interval = 1/self.__frameRate
        while self.__calculating:
            timer = time.clock()
            pixels = self.engine.getFrame()
            frame = self.__drawer.draw(self.engine.parameters,pixels)
            self.curve_canvas_update.emit(len(pixels))
            self.engine.parameters.setTime(self.engine.parameters.time + self.engine.parameters.dt)
            self.__showFrame(frame)
            if self.__writer != None:
                self.__movieRaw.append(img.copy())                
            deltaT = time.clock() - timer
            if deltaT < interval:
                time.sleep(interval-deltaT)
        if self.__writer:
            self.toggleRecording(None)

    def pause(self):
        self.__calculating = False

    def restart(self):
        self.__movieRaw = []
        self.__calculating = False
        self.engine.parameters.setTime(0)
        pixels = self.engine.getFrame()
        frame = self.__drawer.draw(self.engine.parameters,pixels)
        self.__showFrame(frame)
