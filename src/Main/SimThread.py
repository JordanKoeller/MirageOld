# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.6
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import uic
import pyqtgraph as pg
from pyqtgraph import QtCore, QtGui
import threading as par
import time
import imageio
import numpy as np
from Drawer.Drawer import CompositeDrawer
# from Drawer import DiagnosticCompositeDrawer
from Drawer.Drawer import ImageDrawer 
from Drawer import LensedImageLightCurveComposite
from Utility import zeroVector


class SimThread(QtCore.QThread):
    """
    For Internal Use only. 

    Class extending a Qt QThread class. Provides methods for interfacing with the physics engine.
    Enables all calculations to be ran on a separate thread so as to not freeze the GUI.


    PARAMETERS
    ----------

    engine : Engine
        Instance that the SimThread controls
    canvas : QLabel or Matplotlib plot
        Canvas owned by the thread. This is the canas that images generated by the engine are drawn to.
        Default Value: None
    canvasType : CanvasType
        Enum specifying if the canvas is a QLabel-based canvas or a Matplotlib-based canvas.
        DefaultValue: CanvasType.NONE_TYPE

    ATTRIBUTES
    ----------

    canvas : The canvas passed in either upon initialization of with the setCanvas method.

    engine : The engine instance passed in upon initialization of the SimThread instance.


    METHODS
    -------

    setCanvas

    """

    def __init__(self,engine,signals):
        QtCore.QThread.__init__(self)
        self.progress_bar_update  = signals[0]
        self.progress_label_update = signals[1]
        self.image_canvas_update = signals[2]
        self.curve_canvas_update = signals[3]
        self.progress_bar_max_update = signals[4]
        self.__calculating = False
        self.__frameRate = 60
        self.engine = engine
        self.__drawer = LensedImageLightCurveComposite(self.image_canvas_update,self.curve_canvas_update)


    def updateParameters(self,params):
        self.engine.updateParameters(params)

    def run(self):
        self.progress_label_update.emit("Calculating. Please Wait.")
        self.__calculating = True
        interval = 1/self.__frameRate
        counter = 0
        while self.__calculating:
            counter += 1
            timer = time.clock()
            pixels = self.engine.getFrame()
            img = self.__drawer.draw([self.engine.parameters,pixels],[len(pixels)])
            self.engine.incrementTime(self.engine.parameters.dt)
            deltaT = time.clock() - timer
            if deltaT < interval:
                time.sleep(interval-deltaT)


    def pause(self):
        self.__calculating = False

    def restart(self):
        self.__calculating = False
        self.engine.setTime(0)
        pixels = self.engine.getFrame()
        frame = self.__drawer.draw([self.engine.parameters,pixels],[len(pixels)])
        self.__drawer.reset()

    def visualize(self,params):
        drawer = ImageDrawer(self.image_canvas_update)
        self.engine.updateParameters(params)
        pixels = self.engine.visualize()
        frame = drawer.draw([pixels])

    def bin_test(self):
        binszs = np.arange(7000,65000,100)
        reps = 200
        prevRunner = self.run
        self.progress_label_update.emit("Calculating Various Bin Sizes")
        self.progress_bar_max_update.emit(len(binszs))
        # self.__calculating = True
        def runner():
            self.engine.gridTest(binszs, reps,self.curve_canvas_update,self.progress_bar_update)
            # self.__calculating = False
        self.run = runner
        self.start()
        print("Asynchronous")